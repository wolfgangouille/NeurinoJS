// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null)  {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.indexOf('@') === 0 ? path.split('/', 2).join("/") : path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		var localRequire = function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
		if (envRequire) localRequire.fromParentEnvironment = envRequire;
		return localRequire
	};
	return getRequire(modules, [], '');
})
({
	"Desktop": {
		"NeurinoJS": {
			"eNeuron.js": function (exports, module, require) {
				
				const eSyn = require('./eSyn.js');
				
				module.exports = class eNeuron {
					constructor(){
						this.V=0;
						this.Isyn=0;
						this.Iext=0;
						this.Vrest=0.5;
						this.Vreset=-1;
						this.Vthresh=1;
						this.C=0.5;
						this.R=1;
						this.type="LIF";
						this.OutSyns=[];
						this.InSyns=[];
						this.connectTo=function(neuron){
							this.OutSyns.push(new eSyn(neuron))
							neuron.InSyns.push(this.OutSyns[this.OutSyns.length-1])
						}
				
						this.update=function(dt){
							this.OutSyns.forEach((syn, i) => syn.update(dt));
							this.V+=((this.Iext+this.Isyn+((this.Vrest-this.V)/this.R))/this.C)*dt;
							if (this.V>this.Vthresh){
								this.V=this.Vreset;
								this.OutSyns.forEach((syn, i) => syn.fire());
								//console.log("fire !")
							}
						}
						this.computeIsyn=function(){
							this.Isyn=0;
							for (const syn of this.InSyns) { this.Isyn+=syn.I }
						}
					}
				}
			},
			"eSyn.js": function (exports, module, require) {
				module.exports = class eSyn {
					constructor(neuron){
						this.I=0;
						this.I0=0.9;
						this.tau=0.5;
						this.OutNeuron=neuron;
						this.update=function(dt){
							this.I=this.I*Math.exp(-dt/this.tau);
						};
						this.fire=function(){
							this.I+=this.I0;
						};
					}
				}
			},
			"main.js": function (exports, module, require) {
				//const { performance } = require('perf_hooks'); //apparently no need to import it ?
				
				
				const eNeuron = require('./eNeuron.js');
				const eSyn = require('./eSyn.js');
				const neuralNet = require('./neuralNet.js');
				const mesfoncs = require('./mesfoncs.js');
				
				addtoglobnet=mesfoncs.addtoglobnet;
				runGlobalNet=mesfoncs.runGlobalNet;
				addSynapse=mesfoncs.addSynapse;
				//mafonc();
				globalnet=new neuralNet();
				
				console.log(window)
				//console.log(n1);
				//console.log(n2);
			},
			"mesfoncs.js": function (exports, module, require) {
				const eNeuron = require('./eNeuron.js');
				const eSyn = require('./eSyn.js');
				const neuralNet = require('./neuralNet.js');
				
				function runGlobalNet(){
				  applyneurchanges()
				  xdata=[];
				  simuldata=[]; //fix bug here to have unlimited neurons
				  for (let i=0;i<globalnet.Neurons.length;i++){
				    simuldata.push([]);
				  }
				  console.log("Starting simulation")
				  //leI=parseFloat(document.getElementById('i').value);
				
				  document.getElementById('res').value="";
				  let letext="";
				
				  let dt=0.02;
				  var t=0;
				
				  var startTime = performance.now()
				
				  for (let k=0;k<20/dt;k++){
				    t+=dt;
				    letext=letext+(Math.round(t * 100) / 100).toFixed(2)+" ";
				    xdata.push((Math.round(t * 100) / 100));
				    //simuldata[0].push(globalnet.Neurons[0].V);
				    //simuldata[1].push(globalnet.Neurons[1].V);
				    //simuldata[2].push(globalnet.Neurons[1].V);
				    globalnet.update(dt);
				    for (let i=0;i<globalnet.Neurons.length;i++){
				      letext=letext+(Math.round(globalnet.Neurons[i].V * 100) / 100).toFixed(2)+" ";
				      simuldata[i].push(globalnet.Neurons[i].V);
				    }
				    letext=letext+"\n"
				
				
				  }
				
				  var endTime = performance.now()
				
				  console.log(`Simulation took ${endTime - startTime} milliseconds`)
				
				  document.getElementById('res').value=letext;
				  console.log(window)
				  drawGraph();
				}
				
				
				
				
				
				
				
				function addtoglobnet(){
				  globalnet.addNeuron(new eNeuron());
				  var selectBox1=document.getElementById('listn1');
				  var selectBox2=document.getElementById('listn2');
				  console.log(globalnet);
				  let newOption1 = new Option("Neuron "+globalnet.Neurons.length.toString(),globalnet.Neurons[globalnet.Neurons.length-1]);
				  selectBox1.add(newOption1,undefined);
				  let newOption2 = new Option("Neuron "+globalnet.Neurons.length.toString(),globalnet.Neurons[globalnet.Neurons.length-1]);
				  selectBox2.add(newOption2,undefined);
				  displayNeuron()
				}
				
				function addSynapse(){
				  var n1=globalnet.Neurons[(document.getElementById('listn1').selectedIndex)];
				  var n2=globalnet.Neurons[(document.getElementById('listn2').selectedIndex)];
				  n1.connectTo(n2);
				  console.log(globalnet);
				  displayNeuron()
				}
				
				module.exports = { addtoglobnet, runGlobalNet,addSynapse};
			},
			"neuralNet.js": function (exports, module, require) {
				module.exports = class neuralNet {
					constructor(){
						this.Neurons=[];
						this.addNeuron=function(neuron){
							this.Neurons.push(neuron);
						};
						this.update=function(dt){
							for (let i=0;i<this.Neurons.length;i++){
								this.Neurons[i].computeIsyn();
								this.Neurons[i].update(dt);
								//console.log(t+" "+n1.V+" "+n2.V+" "+n1.OutSyns[0].I+" "+n2.OutSyns[0].I);
				
							}
				
						};
					}
				}
			}
		}
	}
})("Desktop/NeurinoJS/main");
